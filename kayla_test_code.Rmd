---
title: "R Notebook"
output: html_notebook
---

write-fisher model

```{r}
#grows the population for the next generation by taking in the population of the previous generation
grow_pop <- function(pop){
  
  #adds 0.3 of the given pop to the given pop to get the new population
  new_pop <- pop + (0.3*pop)
  
  #rounds up to the nearest whole number
  new_pop <- floor(new_pop)
  
  #returns the new population
  return(new_pop)
}
#the function takes in the frequency of the allele (af0), the initial population (pop), and the number of generations it will run (gens)
fisher <- function(af0, pop, gens){
  #creates a numeric vector for the allele frequency and population with the length being the number of gens plus one for the initial generation 
  af = numeric(gens + 1)
  af[1] <- af0
  
  p <- numeric(gens + 1)
  p[1] <- pop
  
  #calculates the allele frequency and population for each generation after the initial gen
  for(i in 1:gens){
    #send the pop for the current gen to a function that will calculate the population of the next gen
    p[i+1] <- grow_pop(p[i]) 
    #uses the binomial distribution to calculate the propability and the new frequency of the allele for the next gen
    x <- rbinom(1, size = 2*p[i+1], prob = af[i])
    af[i+1] <- x/(2*p[i+1])
  }
  
  #creates and returns a dataframe displaying the allele frequency and population of each generation
  stats <- data.frame(gen = 0:gens, allele_frequency = af, population = p)
  return(stats)
}
```

```{r}
#takes in a dataframe that was created from the "fisher" function
snap <- function(df){
  
  #creates a vector called prev_gen that holds the statistics (gen #, allele frequency, population) of the latest generation
  prev_gen <- unlist(df[nrow(df),])
  
  #kills half the population, with new_pop being the population that remains
  new_pop <- prev_gen[3]/2
  new_pop <- floor(new_pop)
  
  #uses the binomial distribution to calculate the propability and the new frequency of the allele for the now halved population
  x <- rbinom(1, size = 2*new_pop, prob = prev_gen[2])
  new_af <- x/(2*new_pop)
  
  #returns a dataframe containing the new population and allele frequency after the bottleneck event
  return(data.frame(gen = prev_gen[1]+1, allele_frequency = new_af, population = new_pop))
}

snap(f)
```

```{r}
#function that takes in frequency of dominant allele and population, then calculates the frequency and population of AA, Aa, and aa
hardy_weinberg <- function(af, pops){

#determines whether the given af is dominant or recessive, then calculates q (recessive trait) and p (dominant trait)
  if(af > 0.5){
    p <- af
    q <- 1-p
  }
  else{
    q <- af
    p <- 1-q
  }
  
  #calculates the genotype
  AA <- p^2
  Aa <- 2*(p*q)
  aa <- q^2
  
  #calculates the population by the frequency of the genotype
  AA_pops <- floor(AA * pops)
  Aa_pops <- floor(Aa * pops)
  aa_pops <- floor(aa*pops)
  
  #checks to ensure that the calculated genotype population equals the total populaton. If calculated pop is too little, add leftover to AA population, if too many, take away from aa population
  check_pops <- AA_pops + Aa_pops + aa_pops
  
  if(check_pops != pops){
    if(check_pops < pops){
      leftover = pops - check_pops
      AA_pops <- AA_pops + leftover
    }
    else{
      over <- check_pops - pops
      aa_pops <- aa_pops - over
    }
  }
  
  #returns a list displaying the recessive trait frequency, dominant trait frequency, genotype frequencies, and the population of each genotype
  return(data.frame(recessive_trait_frequency = q, dominant_trait_frequency  = p, AA_frequency = AA, Aa_frequency = Aa, aa_frequency = aa,AA_population = AA_pops, Aa_population = Aa_pops, aa_population = aa_pops))
}

```

```{r}
test <- hardy_weinberg(0.4, 500)
print(test)
```

```{r}
#create a function that does all the stuff so we don't need to constantly repeat code
all_together <- function(af, pop, gens){
  #dataframe of the initial stats of the first gen
  stats0 <- hardy_weinberg(af, pop)
  print(stats0)
  
  #stores the recessive trait frequency of the original gen
  rtf <- stats0$recessive_trait_frequency
  
  #simiulates the population growth and frequency changes pre snap
  fish1 <- fisher(rtf, pop, gens)
  print(fish1)
  
  #snaps the population in half
  snapped <- snap(fish1)
  print(snapped)
  
  #stores the snapped population and recessive trait frequency
  pop <- as.numeric(snapped$population)
  rtf <- as.numeric(snapped$allele_frequency)
 
  #simulates the population growth and frequency changes post snap
  fish2 <- fisher(rtf, pop, gens)
  print(fish2)
  
  #stores the recessive trait frequency and final population of the last gen
  finalstats <- unlist(fish2[nrow(fish2),])
  ftf <- finalstats[2]
  finalpop <- finalstats[3]
  
  #displays the stats of the last gen
  fstats <- hardy_weinberg(ftf, finalpop)
  print(fstats)
  
}
```

```{r}
i <- all_together(0.1, 300, 20)

```
