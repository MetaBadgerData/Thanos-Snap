---
title: "Thanos-Snap Project"
output: word_document
date: "2023-03-31"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Section One

```{r kayla}
#grows the population for the next generation by taking in the population of the previous generation
grow_pop <- function(pop){
  
  #adds 0.3 of the given pop to the given pop to get the new population
  new_pop <- pop + (0.3*pop)
  
  #rounds up to the nearest whole number
  new_pop <- floor(new_pop)
  
  #returns the new population
  return(new_pop)
}
#the function takes in the frequency of the allele (af0), the initial population (pop), and the number of generations it will run (gens)
fisher <- function(af0, pop, gens){
  #creates a numeric vector for the allele frequency and population with the length being the number of gens plus one for the initial generation 
  af = numeric(gens + 1)
  af[1] <- af0
  
  p <- numeric(gens + 1)
  p[1] <- pop
  
  #calculates the allele frequency and population for each generation after the initial gen
  for(i in 1:gens){
    #send the pop for the current gen to a function that will calculate the population of the next gen
    p[i+1] <- grow_pop(p[i]) 
    #uses the binomial distribution to calculate the propability and the new frequency of the allele for the next gen
    x <- rbinom(1, size = 2*p[i+1], prob = af[i])
    af[i+1] <- x/(2*p[i+1])
  }
  
  #creates and returns a dataframe displaying the allele frequency and population of each generation
  stats <- data.frame(gen = 0:gens, allele_frequency = af, population = p)
  return(stats)
}

#takes in a dataframe that was created from the "fisher" function
snap <- function(df){
  
  #creates a vector called prev_gen that holds the statistics (gen #, allele frequency, population) of the latest generation
  prev_gen <- unlist(df[nrow(df),])
  
  #kills half the population, with new_pop being the population that remains
  new_pop <- prev_gen[3]/2
  
  ##uses the binomial distribution to calculate the propability and the new frequency of the allele for the now halved population
  x <- rbinom(1, size = 2*new_pop, prob = prev_gen[2])
  new_af <- x/(2*new_pop)
  
  #returns a dataframe containing the new population and allele frequency after the bottleneck event
  return(data.frame(gen = prev_gen[1]+1, allele_frequency = prev_gen[2], population = new_pop))
}
```

## Section Two

```{r sophie}

```

## Section Three

```{r White}
#Link to github repo: https://github.com/rstudio/shiny-examples/blob/main/001-hello/app.R
library(shiny)

# Define UI for app that draws a histogram ----
ui <- fluidPage(

  # App title ----
  titlePanel("Hello Shiny!"),

  # Sidebar layout with input and output definitions ----
  sidebarLayout(

    # Sidebar panel for inputs ----
    sidebarPanel(

      # Input: Slider for the number of bins ----
      sliderInput(inputId = "bins",
                  label = "Number of bins:",
                  min = 1,
                  max = 50,
                  value = 30)

    ),

    # Main panel for displaying outputs ----
    mainPanel(

      # Output: Histogram ----
      plotOutput(outputId = "distPlot")

    )
  )
)

# Define server logic required to draw a histogram ----
server <- function(input, output) {

  # Histogram of the Old Faithful Geyser Data ----
  # with requested number of bins
  # This expression that generates a histogram is wrapped in a call
  # to renderPlot to indicate that:
  #
  # 1. It is "reactive" and therefore should be automatically
  #    re-executed when inputs (input$bins) change
  # 2. Its output type is a plot
  output$distPlot <- renderPlot({

    x    <- faithful$waiting
    bins <- seq(min(x), max(x), length.out = input$bins + 1)

    hist(x, breaks = bins, col = "#75AADB", border = "white",
         xlab = "Waiting time to next eruption (in mins)",
         main = "Histogram of waiting times")

    })

}

# Create Shiny app ----
shinyApp(ui = ui, server = server)
```

## Section Four

```{r student4}

```
