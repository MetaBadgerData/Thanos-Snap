---
title: "Thanos-Snap Project"
output: word_document
date: "2023-03-31"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Section One

```{r kayla}
#grows the population for the next generation by taking in the population of the previous generation
grow_pop <- function(pop){
  
  #adds 0.3 of the given pop to the given pop to get the new population
  new_pop <- pop + (0.3*pop)
  
  #rounds up to the nearest whole number
  new_pop <- floor(new_pop)
  
  #returns the new population
  return(new_pop)
}
#the function takes in the frequency of the allele (af0), the initial population (pop), and the number of generations it will run (gens)
fisher <- function(af0, pop, gens){
  #creates a numeric vector for the allele frequency and population with the length being the number of gens plus one for the initial generation 
  af = numeric(gens + 1)
  af[1] <- af0
  
  p <- numeric(gens + 1)
  p[1] <- pop
  
  #calculates the allele frequency and population for each generation after the initial gen
  for(i in 1:gens){
    #send the pop for the current gen to a function that will calculate the population of the next gen
    p[i+1] <- grow_pop(p[i]) 
    #uses the binomial distribution to calculate the propability and the new frequency of the allele for the next gen
    x <- rbinom(1, size = 2*p[i+1], prob = af[i])
    af[i+1] <- x/(2*p[i+1])
  }
  
  #creates and returns a dataframe displaying the allele frequency and population of each generation
  stats <- data.frame(gen = 0:gens, allele_frequency = af, population = p)
  return(stats)
}

#takes in a dataframe that was created from the "fisher" function
snap <- function(df){
  
  #creates a vector called prev_gen that holds the statistics (gen #, allele frequency, population) of the latest generation
  prev_gen <- unlist(df[nrow(df),])
  
  #kills half the population, with new_pop being the population that remains
  new_pop <- prev_gen[3]/2
  new_pop <- floor(new_pop)
  ##uses the binomial distribution to calculate the propability and the new frequency of the allele for the now halved population
  x <- rbinom(1, size = 2*new_pop, prob = prev_gen[2])
  new_af <- x/(2*new_pop)
  
  #returns a dataframe containing the new population and allele frequency after the bottleneck event
  return(data.frame(gen = prev_gen[1]+1, allele_frequency = new_af, population = new_pop))
}

#function that takes in frequency of dominant allele and population, then calculates the frequency and population of AA, Aa, and aa
hardy_weinberg <- function(af, pop){

#determines whether the given af is dominant or recessive, then calculates p (recessive trait) and q (dominant trait)
  if(af < 0.5){
    p <- af
    q <- 1-p
  }
  else{
    q <- af
    p <- 1-q
  }
  
  #calculates the genotype
  AA <- p^2
  Aa <- 2*(p*q)
  aa <- q^2
  
  #calculates the population by the frequency of the genotype
  allele_pops <- c(AA = AA*pop, Aa = Aa*pop, aa = aa*pop)
  
  #returns a list displaying the recessive trait frequency, dominant trait frequency, genotype frequencies, and the population of each genotype
  return(list(recessive_trait = p, dominant_trait = q, genotype_frequency = c(AA = AA, Aa = Aa, aa = aa), genotype_pop = allele_pops ))
}

```

## Section Two

```{r sophie}

#SAMPLE IDEAS
  #initial population size 200 (cats)
  #p= A (Long hair) = .44
  #q = a (Short hair) = .56
  #Bottleneck event affects A (Long hair)?


#code from https://evolutionarygenetics.github.io/Chapter3.html
#code from https://cran.r-project.org/web/packages/evolved/vignettes/popgen_drift.html#:~:text=file_name.jpg)-,Genetic%20drift:%20building%20intuition,You%20have%20just%20observed%20drift!
#reference code sources in report as well

#population & # of alleles
N<-200
n_alleles<-2*N

#hardy weinberg: p^2+2pq+q^2=1 & genotype freqs
p<-.44
q<-1-p

AA<-p^2
Aa<-2*(p*q)
aa<-q^2
genotype_proportion<-c(AA,Aa,aa) #start tracking pop. size increases here
print(genotype_freq)


#drift example: freq of p in generation 1
p1<- rbinom(1,n_alleles,p)/n_alleles
print(p1)

#create for-loop function
#use genotype numbers in for-loop 
# factor in additional (random # of?) offspring (pop. size increase)

# other factors?
# how to add death in bottleneck event & relation to allele

```

## Section Three

```{r White}
#Link to github repo: https://github.com/rstudio/shiny-examples/blob/main/001-hello/app.R
library(shiny)
library(shinythemes)

ui <- fluidPage(
  theme = shinytheme("superhero"),
  titlePanel("Thanos Snap!"),
  
  sidebarLayout(
    sidebarPanel(
      numericInput("popInput", "Set Population:", value = 50, min = 1),
      br(),
      actionButton("growButton", "GROW"),
      actionButton("stopButton", "STOP"),
      actionButton("goButton", "SNAP!"),
      h4("Allele Frequencies"),
      numericInput("pFreq", "Dominant Allele Frequency (p):", 
                  value = 0.5, min = 0, max = 1, step = 0.1),
      numericInput("qFreq", "Recessive Allele Frequency (q):", 
                  value = 0.5, min = 0, max = 1, step = 0.1)
    ),
    
    mainPanel(
      plotOutput("bottleneckPlot", height = "400px"),
      br(),
      textOutput("nText")
    )
  )
)

server <- function(input, output, session) {
  # Reactive values
  population <- reactiveVal(50)
  history <- reactiveVal(c(50))
  growing <- reactiveVal(FALSE)
  max_pop <- reactiveVal(50)
  
  
  
  # Calculate genotype counts based on Hardy-Weinberg
  genotype_counts <- reactive({
    pop <- population()
    p <- input$pFreq
    q <- input$qFreq
    
    # Ensure frequencies sum to 1
    total <- p + q
    if (total > 0) {
      p <- p / total
      q <- q / total
    }
    
    
    list(
      dominant_homozygous = round(pop * p^2),
      heterozygous = round(pop * 2 * p * q),
      recessive_homozygous = round(pop * q^2)
    )
  })
  
  
  
  # Timer for continuous growth
  observe({
    if (growing()) {
      invalidateLater(200, session)  # Update every 200ms for smooth growth
      isolate({
        current_pop <- population()
        new_pop <- current_pop * 1.05
        population(new_pop)
        
        # Update max population if needed
        if (new_pop > max_pop()) {
          max_pop(new_pop)
        }
        
        # Update history
        new_history <- c(history(), new_pop)
        if (length(new_history) > 100) {
          new_history <- tail(new_history, 100)
        }
        history(new_history)
      })
    }
  })
  
  # Event observers
  observeEvent(input$popInput, {
    population(input$popInput)
    history(c(input$popInput))
    max_pop(input$popInput)
  })
  
  observeEvent(input$growButton, {
    growing(TRUE)
  })
  
  observeEvent(input$stopButton, {
    growing(FALSE)
  })
  
  observeEvent(input$goButton, {
    growing(FALSE)
    new_pop <- max(1, round(population() / 2))
    population(new_pop)
    new_history <- c(history(), new_pop)
    if (length(new_history) > 100) {
      new_history <- tail(new_history, 100)
    }
    history(new_history)
  })
  
  
  
  # Update q frequency when p changes to maintain sum = 1
  observeEvent(input$pFreq, {
    updateNumericInput(session, "qFreq", value = 1 - input$pFreq)
  })
  
  observeEvent(input$qFreq, {
    updateNumericInput(session, "pFreq", value = 1 - input$qFreq)
  })
  
  # Outputs
  output$nText <- renderText({
    counts <- genotype_counts()
    paste("Current Population:", round(population()),
          "| AA:", counts$dominant_homozygous,
          "| Aa:", counts$heterozygous, 
          "| aa:", counts$recessive_homozygous)
  })
  
  output$genotypeTable <- renderTable({
    counts <- genotype_counts()
    data.frame(
      Genotype = c("AA (Dominant Homozygous)", "Aa (Heterozygous)", "aa (Recessive Homozygous)"),
      Count = c(counts$dominant_homozygous, counts$heterozygous, counts$recessive_homozygous),
      Percentage = c(
        round(counts$dominant_homozygous / population() * 100, 1),
        round(counts$heterozygous / population() * 100, 1),
        round(counts$recessive_homozygous / population() * 100, 1)
      )
    )
  }, bordered = TRUE, align = 'c')
  
  
  
  
  # Outputs
  output$nText <- renderText({
    paste("Current Population:", round(population()))
  })
  
  output$bottleneckPlot <- renderPlot({
    pops <- history()
    gens <- 1:length(pops)
    counts <- genotype_counts()
    
    # Set up plot area
    par(bg = "#2C3E50", fg = "white", col.main = "white", 
        col.lab = "white", col.axis = "white")
    
    plot(gens, pops, type = "n",
         xlab = "Time Step", ylab = "Population",
         main = "Population Dynamics: Thanos Snap!",
         ylim = c(0, max_pop() * 1.1),
         xlim = c(1, max(10, length(pops))),
         cex.main = 1.2, cex.lab = 1.1, font.main = 2)
    
    # Add grid
    grid(col = "gray30", lty = 3)
    
    current_pop <- tail(pops, 1)
    if (current_pop > 0) {
      prop_AA <- counts$dominant_homozygous / current_pop
      prop_Aa <- counts$heterozygous / current_pop
      prop_aa <- counts$recessive_homozygous / current_pop
      
      # Create stacked areas for genotypes
      if (length(pops) > 1) {
        # Calculate y-values for each genotype section
        y_aa <- pops * prop_aa  # Recessive homozygous at the bottom
        y_Aa <- pops * prop_Aa + y_aa  # Heterozygous in the middle
        y_AA <- pops * prop_AA + y_Aa  # Dominant homozygous at the top (should equal pops)
        
        # Draw the three genotype sections
        polygon(c(gens, rev(gens)), c(y_AA, rev(pops)),
                col = adjustcolor("#E74C3C", alpha.f = 0.7),  # Red for dominant homozygous
                border = NA)
        polygon(c(gens, rev(gens)), c(y_Aa, rev(y_AA)),
                col = adjustcolor("#F39C12", alpha.f = 0.7),  # Orange for heterozygous
                border = NA)
        polygon(c(gens, rev(gens)), c(y_aa, rev(y_Aa)),
                col = adjustcolor("#3498DB", alpha.f = 0.7),  # Blue for recessive homozygous
                border = NA)
      }
    }
    
    
    
    # Fill area under curve
    #polygon(c(gens, rev(gens)), c(pops, rep(0, length(pops))),
    #        col = adjustcolor("lightgreen", alpha.f = 0.6),
    #        border = NA)
    
    # Add line
    #lines(gens, pops, type = "l", lwd = 3, col = "#27AE60")
    
    # Add points
    points(gens, pops, pch = 21, bg = "#2ECC71", col = "white", cex = 1.2)
    
    # Highlight current point
    if (length(pops) > 0) {
      points(length(pops), tail(pops, 1), pch = 21, bg = "red", 
             col = "white", cex = 2, lwd = 2)
    }
    
    # Add legend
    legend("topright", 
           legend = c("AA (Dominant Homozygous)", "Aa (Heterozygous)", "aa (Recessive Homozygous)", "Total Population"),
           fill = c(adjustcolor("#E74C3C", alpha.f = 0.7), 
                   adjustcolor("#F39C12", alpha.f = 0.7), 
                   adjustcolor("#3498DB", alpha.f = 0.7),
                   NA),
           border = c(NA, NA, NA, "white"),
           lty = c(NA, NA, NA, 1),
           lwd = c(NA, NA, NA, 2),
           bg = adjustcolor("#34495E", alpha.f = 0.8),
           box.col = "white")
  })
}

shinyApp(ui = ui, server = server)
```

## Section Four

```{r student4}

```
