---
title: "Thanos-Snap Project"
output: word_document
date: "2023-03-31"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Section One

```{r kayla}
#grows the population for the next generation by taking in the population of the previous generation
grow_pop <- function(pop){
  
  #adds 0.3 of the given pop to the given pop to get the new population
  new_pop <- pop + (0.3*pop)
  
  #rounds up to the nearest whole number
  new_pop <- floor(new_pop)
  
  #returns the new population
  return(new_pop)
}
#the function takes in the frequency of the allele (af0), the initial population (pop), and the number of generations it will run (gens)
fisher <- function(af0, pop, gens){
  #creates a numeric vector for the allele frequency and population with the length being the number of gens plus one for the initial generation 
  af = numeric(gens + 1)
  af[1] <- af0
  
  p <- numeric(gens + 1)
  p[1] <- pop
  
  #calculates the allele frequency and population for each generation after the initial gen
  for(i in 1:gens){
    #send the pop for the current gen to a function that will calculate the population of the next gen
    p[i+1] <- grow_pop(p[i]) 
    #uses the binomial distribution to calculate the propability and the new frequency of the allele for the next gen
    x <- rbinom(1, size = 2*p[i+1], prob = af[i])
    af[i+1] <- x/(2*p[i+1])
  }
  
  #creates and returns a dataframe displaying the allele frequency and population of each generation
  stats <- data.frame(gen = 0:gens, allele_frequency = af, population = p)
  return(stats)
}

#takes in a dataframe that was created from the "fisher" function
snap <- function(df){
  
  #creates a vector called prev_gen that holds the statistics (gen #, allele frequency, population) of the latest generation
  prev_gen <- unlist(df[nrow(df),])
  
  #kills half the population, with new_pop being the population that remains
  new_pop <- prev_gen[3]/2
  new_pop <- floor(new_pop)
  ##uses the binomial distribution to calculate the propability and the new frequency of the allele for the now halved population
  x <- rbinom(1, size = 2*new_pop, prob = prev_gen[2])
  new_af <- x/(2*new_pop)
  
  #returns a dataframe containing the new population and allele frequency after the bottleneck event
  return(data.frame(gen = prev_gen[1]+1, allele_frequency = new_af, population = new_pop))
}


#function that takes in frequency of dominant allele and population, then calculates the frequency and population of AA, Aa, and aa
hardy_weinberg <- function(af, pops){

#determines whether the given af is dominant or recessive, then calculates q (recessive trait) and p (dominant trait)
  if(af > 0.5){
    p <- af
    q <- 1-p
  }
  else{
    q <- af
    p <- 1-q
  }
  
  #calculates the genotype
  AA <- p^2
  Aa <- 2*(p*q)
  aa <- q^2
  
  #calculates the population by the frequency of the genotype
  AA_pops <- floor(AA * pops)
  Aa_pops <- floor(Aa * pops)
  aa_pops <- floor(aa*pops)
  
  #checks to ensure that the calculated genotype population equals the total populaton. If calculated pop is too little, add leftover to AA population, if too many, take away from aa population
  check_pops <- AA_pops + Aa_pops + aa_pops
  
  if(check_pops != pops){
    if(check_pops < pops){
      leftover = pops - check_pops
      AA_pops <- AA_pops + leftover
    }
    else{
      over <- check_pops - pops
      aa_pops <- aa_pops - over
    }
  }
  
  #returns a list displaying the recessive trait frequency, dominant trait frequency, genotype frequencies, and the population of each genotype
  return(data.frame(recessive_trait_frequency = q, dominant_trait_frequency  = p, AA_frequency = AA, Aa_frequency = Aa, aa_frequency = aa,AA_population = AA_pops, Aa_population = Aa_pops, aa_population = aa_pops))
}


#create a function that does all the stuff so we don't need to constantly repeat code
all_together <- function(af, pop, gens){
  #dataframe of the initial stats of the first gen
  stats0 <- hardy_weinberg(af, pop)
  print(stats0)
  
  #stores the recessive trait frequency of the original gen
  rtf <- stats0$recessive_trait_frequency
  
  #simiulates the population growth and frequency changes pre snap
  fish1 <- fisher(rtf, pop, gens)
  print(fish1)
  
  #snaps the population in half
  snapped <- snap(fish1)
  print(snapped)
  
  #stores the snapped population and recessive trait frequency
  pop <- as.numeric(snapped$population)
  rtf <- as.numeric(snapped$allele_frequency)
 
  #simulates the population growth and frequency changes post snap
  fish2 <- fisher(rtf, pop, gens)
  print(fish2)
  
  #stores the recessive trait frequency and final population of the last gen
  finalstats <- unlist(fish2[nrow(fish2),])
  ftf <- finalstats[2]
  finalpop <- finalstats[3]
  
  #displays the stats of the last gen
  fstats <- hardy_weinberg(ftf, finalpop)
  print(fstats)
  
}
```

## Section Two

```{r sophie}
library(tidyverse)

#CODE SOURCE

#https://evolutionarygenetics.github.io/Chapter3.html
#https://cran.r-project.org/web/packages/evolved/vignettes/popgen_drift.html#:~:text=file_name.jpg)-,Genetic%20drift:%20building%20intuition,You%20have%20just%20observed%20drift!



#CATS

#long hair allele- A
#short hair allele- a

#initial pop
pop_size<- 100#add                                   *
total_alleles<- 2*pop_size

#initial allele freqs 
#hardy-weinberg p^2+2pq+q^2=1 where p=A and q=a
p<- .33#add                                          *
q<- 1-p

#generations
gens<- 20#add                                       *
  
 

#GENOTYPE PROPS 
#p^2+2pq+q^2=1
AA<-p^2
Aa<-2*(p*q)
aa<-q^2
genotype_props<-c(AA,Aa,aa)
genotype_pop_props<-c(AA,Aa,aa)*pop_size
#print(data.frame(genotype_pop_props))
#names(genotype_pop_props)<-c("AA","Aa","aa")


#POPULATION INCREASES

#discrete time logistic growth model
current_ts_pop<- data.frame("AA"=genotype_pop_props[1],"Aa"=genotype_pop_props[2],"aa"=genotype_pop_props[3]) 
growth_rate<- .05#add                                    *
K<- 20000#add                                                *
  
for(i in 1:gens){
  pop_incr<-current_ts_pop[i,]+(growth_rate*current_ts_pop[i,]*(1-(current_ts_pop[i,]/K))) 
  current_ts_pop[i+1,]<-ceiling(pop_incr)
}

print(current_ts_pop)

```

## Section Three

```{r White}
#Link to github repo: https://github.com/rstudio/shiny-examples/blob/main/001-hello/app.R
library(shiny)
library(shinythemes)

ui <- fluidPage(
  theme = shinytheme("superhero"),
  titlePanel("Thanos Snap!"),
  
  sidebarLayout(
    sidebarPanel(
      numericInput("popInput", "Set Population:", value = 50, min = 1),
      br(),
      actionButton("growButton", "GROW"),
      actionButton("stopButton", "STOP"),
      actionButton("goButton", "SNAP!"),
      h4("Allele Frequencies"),
      numericInput("pFreq", "Dominant Allele Frequency (p):", 
                  value = 0.5, min = 0, max = 1, step = 0.1),
      numericInput("qFreq", "Recessive Allele Frequency (q):", 
                  value = 0.5, min = 0, max = 1, step = 0.1)
    ),
    
    mainPanel(
      plotOutput("bottleneckPlot", height = "400px"),
      br(),
      textOutput("nText")
    )
  )
)

server <- function(input, output, session) {
  # Reactive values
  population <- reactiveVal(50)
  history <- reactiveVal(c(50))
  growing <- reactiveVal(FALSE)
  max_pop <- reactiveVal(50)
  
  
  
  # Calculate genotype counts based on Hardy-Weinberg
  genotype_counts <- reactive({
    pop <- population()
    p <- input$pFreq
    q <- input$qFreq
    
    # Ensure frequencies sum to 1
    total <- p + q
    if (total > 0) {
      p <- p / total
      q <- q / total
    }
    
    
    list(
      dominant_homozygous = round(pop * p^2),
      heterozygous = round(pop * 2 * p * q),
      recessive_homozygous = round(pop * q^2)
    )
  })
  
  
  
  # Timer for continuous growth
  observe({
    if (growing()) {
      invalidateLater(200, session)  # Update every 200ms for smooth growth
      isolate({
        current_pop <- population()
        new_pop <- current_pop * 1.05
        population(new_pop)
        
        # Update max population if needed
        if (new_pop > max_pop()) {
          max_pop(new_pop)
        }
        
        # Update history
        new_history <- c(history(), new_pop)
        if (length(new_history) > 100) {
          new_history <- tail(new_history, 100)
        }
        history(new_history)
      })
    }
  })
  
  # Event observers
  observeEvent(input$popInput, {
    population(input$popInput)
    history(c(input$popInput))
    max_pop(input$popInput)
  })
  
  observeEvent(input$growButton, {
    growing(TRUE)
  })
  
  observeEvent(input$stopButton, {
    growing(FALSE)
  })
  
  observeEvent(input$goButton, {
    growing(FALSE)
    new_pop <- max(1, round(population() / 2))
    population(new_pop)
    new_history <- c(history(), new_pop)
    if (length(new_history) > 100) {
      new_history <- tail(new_history, 100)
    }
    history(new_history)
  })
  
  
  
  # Update q frequency when p changes to maintain sum = 1
  observeEvent(input$pFreq, {
    updateNumericInput(session, "qFreq", value = 1 - input$pFreq)
  })
  
  observeEvent(input$qFreq, {
    updateNumericInput(session, "pFreq", value = 1 - input$qFreq)
  })
  
  # Outputs
  output$nText <- renderText({
    counts <- genotype_counts()
    paste("Current Population:", round(population()),
          "| AA:", counts$dominant_homozygous,
          "| Aa:", counts$heterozygous, 
          "| aa:", counts$recessive_homozygous)
  })
  
  output$genotypeTable <- renderTable({
    counts <- genotype_counts()
    pop <- population()
    if (pop > 0) {
      data.frame(
        Genotype = c("AA (Dominant Homozygous)", "Aa (Heterozygous)", "aa (Recessive Homozygous)"),
        Count = c(counts$dominant_homozygous, counts$heterozygous, counts$recessive_homozygous),
        Percentage = c(
          round(counts$dominant_homozygous / pop * 100, 1),
          round(counts$heterozygous / pop * 100, 1),
          round(counts$recessive_homozygous / pop * 100, 1)
        )
      )
    }
  }, bordered = TRUE, align = 'c')
  
  output$bottleneckPlot <- renderPlot({
    pops <- history()
    if (length(pops) == 0) return()
    
    gens <- 1:length(pops)
    counts <- genotype_counts()
    
    # Set up plot area
    par(bg = "#2C3E50", fg = "white", col.main = "white", 
        col.lab = "white", col.axis = "white")
    
    plot(gens, pops, type = "n",
         xlab = "Time Step", ylab = "Population",
         main = "Population Dynamics: Thanos Snap!",
         ylim = c(0, max_pop() * 1.1),
         xlim = c(1, max(10, length(pops))),
         cex.main = 1.2, cex.lab = 1.1, font.main = 2)
    
    # Add grid
    grid(col = "gray30", lty = 3)
    
    current_pop <- tail(pops, 1)
    if (current_pop > 0) {
      prop_AA <- counts$dominant_homozygous / current_pop
      prop_Aa <- counts$heterozygous / current_pop
      prop_aa <- counts$recessive_homozygous / current_pop
      
      # Create stacked areas for genotypes
      if (length(pops) > 1) {
        # Calculate y-values for each genotype section
        y_aa <- pops * prop_aa  # Recessive homozygous at the bottom
        y_Aa <- pops * prop_Aa + y_aa  # Heterozygous in the middle
        y_AA <- pops * prop_AA + y_Aa  # Dominant homozygous at the top (should equal pops)
        
        # Draw the three genotype sections
        # 1. Bottom: recessive homozygous (aa)
        polygon(c(gens, rev(gens)), c(y_aa, rep(0, length(pops))),
                col = adjustcolor("#3498DB", alpha.f = 0.7),  # Blue
                border = NA)
        
        # 2. Middle: heterozygous (Aa)
        polygon(c(gens, rev(gens)), c(y_Aa, rev(y_aa)),
                col = adjustcolor("#F39C12", alpha.f = 0.7),  # Orange
                border = NA)
        
        # 3. Top: dominant homozygous (AA)
        polygon(c(gens, rev(gens)), c(y_AA, rev(y_Aa)),
                col = adjustcolor("#E74C3C", alpha.f = 0.7),  # Red
                border = NA)
      }
    }
    
    
    
    # Fill area under curve
    #polygon(c(gens, rev(gens)), c(pops, rep(0, length(pops))),
    #        col = adjustcolor("lightgreen", alpha.f = 0.6),
    #        border = NA)
    
    # Add line
    #lines(gens, pops, type = "l", lwd = 3, col = "#27AE60")
    
    # Add points
    points(gens, pops, pch = 21, bg = "#2ECC71", col = "white", cex = 1.2)
    
    # Highlight current point
    if (length(pops) > 0) {
      points(length(pops), tail(pops, 1), pch = 21, bg = "red", 
             col = "white", cex = 2, lwd = 2)
    }
    
    # Add legend
    legend("topright", 
           legend = c("AA (Dominant Homozygous)", "Aa (Heterozygous)", "aa (Recessive Homozygous)", "Total Population"),
           fill = c(adjustcolor("#E74C3C", alpha.f = 0.7), 
                   adjustcolor("#F39C12", alpha.f = 0.7), 
                   adjustcolor("#3498DB", alpha.f = 0.7),
                   NA),
           border = c(NA, NA, NA, "white"),
           lty = c(NA, NA, NA, 1),
           lwd = c(NA, NA, NA, 2),
           bg = adjustcolor("#34495E", alpha.f = 0.8),
           box.col = "white")
  })
}

shinyApp(ui = ui, server = server)
```

## Section Four

```{r student4}

```
