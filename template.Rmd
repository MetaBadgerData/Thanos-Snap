---
title: "Thanos-Snap Project"
output: word_document
date: "2023-03-31"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Section One

```{r kayla}

#grows the population for the next generation by taking in the population of the previous generation
grow_pop <- function(pop, grow_rate){
  
  #adds 0.3 of the given pop to the given pop to get the new population
  new_pop <- pop + (grow_rate*pop)
  
  #rounds up to the nearest whole number
  new_pop <- floor(new_pop)
  
  #returns the new population
  return(new_pop)
}
#the function takes in the frequency of the allele (af0), the initial population (pop), and the number of generations it will run (gens)
fisher <- function(af0, pop, gens, grow_rate){
  #creates a numeric vector for the allele frequency and population with the length being the number of gens plus one for the initial generation 
  af = numeric(gens + 1)
  af[1] <- af0
  
  p <- numeric(gens + 1)
  p[1] <- pop
  
  #calculates the allele frequency and population for each generation after the initial gen
  for(i in 1:gens){
    #send the pop for the current gen to a function that will calculate the population of the next gen
    p[i+1] <- grow_pop(p[i], grow_rate) 
    #uses the binomial distribution to calculate the propability and the new frequency of the allele for the next gen
    x <- rbinom(1, size = 2*p[i+1], prob = af[i])
    af[i+1] <- x/(2*p[i+1])
  }
  
  #creates and returns a dataframe displaying the allele frequency and population of each generation
  stats <- data.frame(gen = 0:gens, allele_frequency = af, population = p)
  return(stats)
}

#takes in a dataframe that was created from the "fisher" function
snap <- function(df){
  
  #creates a vector called prev_gen that holds the statistics (gen #, allele frequency, population) of the latest generation
  prev_gen <- unlist(df[nrow(df),])
  
  #kills half the population, with new_pop being the population that remains
  new_pop <- prev_gen[3]/2
  new_pop <- floor(new_pop)
  ##uses the binomial distribution to calculate the propability and the new frequency of the allele for the now halved population
  x <- rbinom(1, size = 2*new_pop, prob = prev_gen[2])
  new_af <- x/(2*new_pop)
  
  #returns a dataframe containing the new population and allele frequency after the bottleneck event
  return(data.frame(gen = prev_gen[1]+1, allele_frequency = new_af, population = new_pop))
}


#function that takes in frequency of dominant allele and population, then calculates the frequency and population of AA, Aa, and aa
hardy_weinberg <- function(af, pops){

#determines whether the given af is dominant or recessive, then calculates q (recessive trait) and p (dominant trait)
  if(af > 0.5){
    p <- af
    q <- 1-p
  }
  else{
    q <- af
    p <- 1-q
  }
  
  #calculates the genotype
  AA <- p^2
  Aa <- 2*(p*q)
  aa <- q^2
  
  #calculates the population by the frequency of the genotype
  AA_pops <- floor(AA * pops)
  Aa_pops <- floor(Aa * pops)
  aa_pops <- floor(aa*pops)
  
  #checks to ensure that the calculated genotype population equals the total populaton. If calculated pop is too little, add leftover to AA population, if too many, take away from aa population
  check_pops <- AA_pops + Aa_pops + aa_pops
  
  if(check_pops != pops){
    if(check_pops < pops){
      leftover = pops - check_pops
      AA_pops <- AA_pops + leftover
    }
    else{
      over <- check_pops - pops
      aa_pops <- aa_pops - over
    }
  }
  
  #returns a list displaying the recessive trait frequency, dominant trait frequency, genotype frequencies, and the population of each genotype
  return(data.frame(recessive_trait_frequency = q, dominant_trait_frequency  = p, AA_frequency = AA, Aa_frequency = Aa, aa_frequency = aa,AA_population = AA_pops, Aa_population = Aa_pops, aa_population = aa_pops))
}


#create a function that does all the stuff so we don't need to constantly repeat code
all_together <- function(af, pop, gens, grow_rate){
  #dataframe of the initial stats of the first gen
  stats0 <- hardy_weinberg(af, pop)
  print(stats0)
  
  #stores the recessive trait frequency of the original gen
  rtf <- stats0$recessive_trait_frequency
  
  #simiulates the population growth and frequency changes pre snap
  fish1 <- fisher(rtf, pop, gens, grow_rate)
  print(fish1)
  
  #snaps the population in half
  snapped <- snap(fish1)
  print(snapped)
  
  #stores the snapped population and recessive trait frequency
  pop <- as.numeric(snapped$population)
  rtf <- as.numeric(snapped$allele_frequency)
 
  #simulates the population growth and frequency changes post snap
  fish2 <- fisher(rtf, pop, gens, grow_rate)
  print(fish2)
  
  #stores the recessive trait frequency and final population of the last gen
  finalstats <- unlist(fish2[nrow(fish2),])
  ftf <- finalstats[2]
  finalpop <- finalstats[3]
  
  #displays the stats of the last gen
  fstats <- hardy_weinberg(ftf, finalpop)
  print(fstats)
  
}
```

## Section Two

```{r sophie}
library(tidyverse)

# * means places to add values

#CATS

#long hair allele- A
#short hair allele- a

#initial pop
pop_size<- 100#add                                   *
total_alleles<- 2*pop_size

#initial allele freqs 
#hardy-weinberg p^2+2pq+q^2=1 where p=A and q=a
p<- .33#add                                          *
q<- 1-p

#generations
gens<- 20#add                                       *
  
 

#GENOTYPE PROPS 
#p^2+2pq+q^2=1
AA<-p^2
Aa<-2*(p*q)
aa<-q^2
genotype_props<-c(AA,Aa,aa)
genotype_pop_props<-c(AA,Aa,aa)*pop_size
#print(data.frame(genotype_pop_props))
#names(genotype_pop_props)<-c("AA","Aa","aa")


#POPULATION INCREASES

#discrete time logistic growth model
current_ts_pop<- data.frame("AA"=genotype_pop_props[1],"Aa"=genotype_pop_props[2],"aa"=genotype_pop_props[3]) 
growth_rate<- .05#add                                    *
K<- 20000#add                                                *
  
for(i in 1:gens){
  pop_incr<-current_ts_pop[i,]+(growth_rate*current_ts_pop[i,]*(1-(current_ts_pop[i,]/K))) 
  current_ts_pop[i+1,]<-ceiling(pop_incr)
}

print(current_ts_pop)



#BOTTLENECK EVENT (THANOS SNAP)

#sample for remaining population after snap
current_ts_pop<-tail(current_ts_pop,n=1)
snap<- .5#add                                               *
size<-snap*rowSums(current_ts_pop)
survivor_props<-sample(c("AA","Aa","aa"),size, replace=TRUE, current_ts_pop)

survivor_props<-data.frame(survivor_props) %>% count(survivor_props) %>%   pivot_wider(names_from=survivor_props,values_from = n)
print(survivor_props)

#population growth and genetic drift with rbinom
gens<- 20#add                                     *

for(i in 1:gens){
  pop_incr<-survivor_props[i,]+(growth_rate*survivor_props[i,]*(1-(survivor_props[i,]/K))) 
  survivor_props[i+1,]<-ceiling(pop_incr)
}

print(survivor_props)

```

## Section Three

```{r White}
#Link to github repo: https://github.com/rstudio/shiny-examples/blob/main/001-hello/app.R
#https://stackoverflow.com/questions/68215218/is-there-a-way-to-create-a-icon-action-button-for-r-shiny
#link to icons https://getbootstrap.com/docs/3.3/components/#glyphicons
library(shiny)
library(shinythemes)
library(tidyverse)

#SOPHIE'S IDEAS
# Logistic growth function
logistic_growth <- function(current_pop, growth_rate, K) {
  new_pop <- current_pop + (growth_rate * current_pop * (1 - (current_pop / K)))
  return(ceiling(new_pop))
}

# Bottleneck event (Thanos snap) with sampling
apply_snap <- function(current_pop, snap_proportion = 0.5) {
  # Get the last generation
  last_gen <- tail(current_pop, 1)
  total_pop <- sum(last_gen)
  
  # Calculate survivors
  size <- snap_proportion * total_pop
  
  # Create genotype vector based on proportions
  genotypes <- c(
    rep("AA", last_gen$AA),
    rep("Aa", last_gen$Aa),
    rep("aa", last_gen$aa)
  )
  
  # Sample survivors
  if (length(genotypes) > 0 && size > 0) {
    survivor_genotypes <- sample(genotypes, size, replace = FALSE)
    
    # Count survivors by genotype
    survivor_counts <- table(survivor_genotypes)
    
    # Create data frame with all genotypes (ensuring all are present)
    survivors <- data.frame(
      AA = ifelse("AA" %in% names(survivor_counts), survivor_counts[["AA"]], 0),
      Aa = ifelse("Aa" %in% names(survivor_counts), survivor_counts[["Aa"]], 0),
      aa = ifelse("aa" %in% names(survivor_counts), survivor_counts[["aa"]], 0)
    )
  } else {
    survivors <- data.frame(AA = 0, Aa = 0, aa = 0)
  }
  
  return(survivors)
}


#Kayla's logic
# Calculate Hardy-Weinberg equilibrium
hardy_weinberg <- function(p, pop) {
  q <- 1 - p
  
  # Calculate genotype frequencies
  AA_freq <- p^2
  Aa_freq <- 2 * p * q
  aa_freq <- q^2
  
  # Calculate genotype populations
  AA_pop <- round(AA_freq * pop)
  Aa_pop <- round(Aa_freq * pop)
  aa_pop <- round(aa_freq * pop)
  
  total <- AA_pop + Aa_pop + aa_pop
  if (total != pop) {
    diff <- pop - total
    if (AA_pop >= Aa_pop & AA_pop >= aa_pop) {
      AA_pop <- AA_pop + diff
    } else if (Aa_pop >= AA_pop & Aa_pop >= aa_pop) {
      Aa_pop <- Aa_pop + diff
    } else {
      aa_pop <- aa_pop + diff
    }
  }
  
  return(list(
    dominant_freq = p,
    recessive_freq = q,
    AA_frequency = AA_freq,
    Aa_frequency = Aa_freq,
    aa_frequency = aa_freq,
    AA_population = AA_pop,
    Aa_population = Aa_pop,
    aa_population = aa_pop
  ))
}

ui <- fluidPage(
  theme = shinytheme("superhero"),
  titlePanel("Thanos Snap! - Cat Hair Genetics"),
  
  sidebarLayout(
    sidebarPanel(
      h4("Population Parameters"),
      numericInput("popInput", "Initial Population:", value = 100, min = 1),
      numericInput("KInput", "Carrying Capacity (K):", value = 2000, min = 10),
      numericInput("growthInput", "Growth Rate (r):", value = 0.05, min = 0, max = 1, step = 0.01),
      
      br(),
      h4("Allele Frequencies"),
      helpText("A = long hair (dominant), a = short hair (recessive)"),
      numericInput("pFreq", "Dominant Allele Frequency (p):", 
                  value = 0.33, min = 0, max = 1, step = 0.01),
      numericInput("qFreq", "Recessive Allele Frequency (q):", 
                  value = 0.67, min = 0, max = 1, step = 0.01),
      
      br(),
      h4("Bottleneck Event"),
      sliderInput("snapInput", "Snap Proportion:", 
                  value = 0.5, min = 0.1, max = 0.9, step = 0.1),
      
      br(),
      actionButton("growButton", "GROW"),
      actionButton("stopButton", "STOP"),
      actionButton("snapButton", "SNAP!", icon("scissors"), 
    style="color: #fff; background-color: #6d3678; border-color: ##573D76"),
      actionButton("resetButton", "RESET"),
      
      br(),
      br(),
      h5("Current Status:"),
      textOutput("statusText"),
      br(),
      h5("Current Population:"),
      textOutput("currentPopulation"),
      br(),
      h5("Current Genotype Counts:"),
      textOutput("genotypeCounts")
    ),
    
    mainPanel(
      plotOutput("genotypePlot", height = "500px"),
      br(),
      tableOutput("genotypeTable"),
      br(),
      h5("USER MANUAL")
    )
  )
)

server <- function(input, output, session) {
  # Reactive values
  population_data <- reactiveVal(NULL)
  growing <- reactiveVal(FALSE)
  phase <- reactiveVal("Pre-snap")
  history <- reactiveVal(list())
  
  # Update q frequency when p changes
  observeEvent(input$pFreq, {
    updateNumericInput(session, "qFreq", value = 1 - input$pFreq)
  })
  
  observeEvent(input$qFreq, {
    updateNumericInput(session, "pFreq", value = 1 - input$qFreq)
  })
  
  # Initialize population
  initialize_population <- function() {
    hw <- hardy_weinberg(input$pFreq, input$popInput)
    initial_data <- data.frame(
      generation = 0,
      AA = hw$AA_population,
      Aa = hw$Aa_population,
      aa = hw$aa_population,
      total = hw$AA_population + hw$Aa_population + hw$aa_population,
      p_freq = hw$dominant_freq,
      q_freq = hw$recessive_freq,
      phase = "Initial"
    )
    population_data(list(initial_data))
    history(list(pre_snap = initial_data))
    phase("Pre-snap")
    growing(FALSE)
  }
  
  observeEvent(input$popInput, {
    initialize_population()
  }, ignoreInit = FALSE)
  
  observeEvent(input$resetButton, {
    initialize_population()
  })
  
  observe({
    if (growing()) {
      invalidateLater(500, session)
      isolate({
        current_data <- population_data()
        if (!is.null(current_data) && length(current_data) > 0) {
          
          if (phase() == "Pre-snap") {
            last_gen <- tail(current_data[[1]], 1)
            
            new_AA <- logistic_growth(last_gen$AA, input$growthInput, input$KInput)
            new_Aa <- logistic_growth(last_gen$Aa, input$growthInput, input$KInput)
            new_aa <- logistic_growth(last_gen$aa, input$growthInput, input$KInput)
            
            # Calculate allele frequencies
            total_pop <- new_AA + new_Aa + new_aa
            p_freq <- (2*new_AA + new_Aa) / (2*total_pop)
            q_freq <- 1 - p_freq
            
            new_gen <- data.frame(
              generation = last_gen$generation + 1,
              AA = new_AA,
              Aa = new_Aa,
              aa = new_aa,
              total = total_pop,
              p_freq = p_freq,
              q_freq = q_freq,
              phase = "Pre-snap"
            )
            
            # Update pre-snap data
            updated_pre_snap <- rbind(current_data[[1]], new_gen)
            
            # If we have post-snap data, keep it
            if (length(current_data) == 2) {
              population_data(list(updated_pre_snap, current_data[[2]]))
              history(list(pre_snap = updated_pre_snap, 
                          snap = history()$snap, 
                          post_snap = history()$post_snap))
            } else {
              population_data(list(updated_pre_snap))
              history(list(pre_snap = updated_pre_snap))
            }
            
          } else if (phase() == "Post-snap") {
            # Get the last generation from post-snap data
            if (length(current_data) == 2) {
              last_gen <- tail(current_data[[2]], 1)
              
              # Apply logistic growth to each genotype separately
              new_AA <- logistic_growth(last_gen$AA, input$growthInput, input$KInput)
              new_Aa <- logistic_growth(last_gen$Aa, input$growthInput, input$KInput)
              new_aa <- logistic_growth(last_gen$aa, input$growthInput, input$KInput)
              
              # Calculate allele frequencies
              total_pop <- new_AA + new_Aa + new_aa
              p_freq <- (2*new_AA + new_Aa) / (2*total_pop)
              q_freq <- 1 - p_freq
              
              new_gen <- data.frame(
                generation = last_gen$generation + 1,
                AA = new_AA,
                Aa = new_Aa,
                aa = new_aa,
                total = total_pop,
                p_freq = p_freq,
                q_freq = q_freq,
                phase = "Post-snap"
              )
              
              # Update post-snap data
              updated_post_snap <- rbind(current_data[[2]], new_gen)
              population_data(list(current_data[[1]], updated_post_snap))
              history(list(pre_snap = history()$pre_snap, 
                          snap = history()$snap, 
                          post_snap = updated_post_snap))
            }
          }
        }
      })
    }
  })
  
  # Event observers
  observeEvent(input$growButton, {
    growing(TRUE)
    if (is.null(population_data())) {
      initialize_population()
    }
  })
  
  observeEvent(input$stopButton, {
    growing(FALSE)
  })
  
  observeEvent(input$snapButton, {
    # Stop growth temporarily
    was_growing <- growing()
    growing(FALSE)
    
    if (!is.null(population_data())) {
      current_data <- population_data()
      
      # If we're in pre-snap phase, apply the snap
      if (phase() == "Pre-snap") {
        last_gen <- tail(current_data[[1]], 1)
        
        # Create current population data frame for sampling
        current_pop <- data.frame(
          AA = last_gen$AA,
          Aa = last_gen$Aa,
          aa = last_gen$aa
        )
        
        # Apply bottleneck
        survivors <- apply_snap(current_pop, input$snapInput)
        
        # Calculate new allele frequencies
        total_survivors <- sum(survivors)
        p_freq <- ifelse(total_survivors > 0, (2*survivors$AA + survivors$Aa) / (2*total_survivors), 0)
        q_freq <- 1 - p_freq
        
        snap_gen <- data.frame(
          generation = last_gen$generation + 1,
          AA = survivors$AA,
          Aa = survivors$Aa,
          aa = survivors$aa,
          total = total_survivors,
          p_freq = p_freq,
          q_freq = q_freq,
          phase = "Snap"
        )
        
        # Switch to post-snap phase
        phase("Post-snap")
        
        # Update data - keep pre-snap history and add snap + initial post-snap
        population_data(list(current_data[[1]], snap_gen))
        history(list(pre_snap = current_data[[1]], 
                    snap = snap_gen, 
                    post_snap = snap_gen))
        
        # Restart growth if it was running
        if (was_growing) {
          growing(TRUE)
        }
      }
    }
  })
  
  # Status text
  output$statusText <- renderText({
    if (is.null(population_data())) {
      "Click GROW to start simulation"
    } else {
      paste(phase(), "phase | Generation:", 
            ifelse(phase() == "Pre-snap", 
                   tail(population_data()[[1]], 1)$generation,
                   tail(population_data()[[2]], 1)$generation))
    }
  })
  
  # Current population text
  output$currentPopulation <- renderText({
    if (is.null(population_data())) return("N/A")
    
    current_data <- population_data()
    if (phase() == "Pre-snap") {
      last_gen <- tail(current_data[[1]], 1)
    } else {
      last_gen <- tail(current_data[[2]], 1)
    }
    
    paste("Total:", last_gen$total, "cats")
  })
  
  # Genotype counts text
  output$genotypeCounts <- renderText({
    if (is.null(population_data())) return("N/A")
    
    current_data <- population_data()
    if (phase() == "Pre-snap") {
      last_gen <- tail(current_data[[1]], 1)
    } else {
      last_gen <- tail(current_data[[2]], 1)
    }
    
    paste("AA:", last_gen$AA, "| Aa:", last_gen$Aa, "| aa:", last_gen$aa)
  })
  
  # Genotype composition plot (main visualization)
  output$genotypePlot <- renderPlot({
    if (is.null(population_data())) {
      # Show empty plot with instructions
      par(bg = "#2C3E50", fg = "white", col.main = "white", 
          col.lab = "white", col.axis = "white")
      plot(0, 0, type = "n", xlim = c(0, 1), ylim = c(0, 1),
           xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = "")
      text(0.5, 0.5, "Click GROW to start simulation", 
           cex = 1.5, col = "white")
      return()
    }
    
    current_data <- population_data()
    
    # Combine all data for the entire history
    if (length(current_data) == 1) {
      plot_data <- current_data[[1]]
    } else {
      plot_data <- rbind(current_data[[1]], current_data[[2]])
    }
    
    # Prepare data for stacked area plot
    generations <- plot_data$generation
    AA_counts <- plot_data$AA
    Aa_counts <- plot_data$Aa
    aa_counts <- plot_data$aa
    
    par(bg = "#2C3E50", fg = "white", col.main = "white", 
        col.lab = "white", col.axis = "white")
    
    # Set up plot area
    plot(generations, AA_counts + Aa_counts + aa_counts, type = "n",
         xlab = "Generation", ylab = "Number of Cats",
         main = "Cat Hair Genotype Composition Over Time",
         ylim = c(0, max(AA_counts + Aa_counts + aa_counts) * 1.1),
         xlim = c(0, max(generations) + 1))
    
    # Add grid
    grid(col = "gray30", lty = 3)
    
    # Create stacked areas for genotype composition
    if (length(generations) > 1) {
      # Bottom layer: aa genotype (short hair - recessive homozygous)
      polygon(c(generations, rev(generations)), 
              c(AA_counts + Aa_counts + aa_counts, rep(0, length(generations))),
              col = adjustcolor("#3498DB", alpha.f = 0.7), border = NA)
      
      # Middle layer: Aa genotype (long hair - heterozygous)
      polygon(c(generations, rev(generations)), 
              c(AA_counts + Aa_counts, rev(AA_counts + Aa_counts + aa_counts)),
              col = adjustcolor("#F39C12", alpha.f = 0.7), border = NA)
      
      # Top layer: AA genotype (long hair - homozygous dominant)
      polygon(c(generations, rev(generations)), 
              c(AA_counts, rev(AA_counts + Aa_counts)),
              col = adjustcolor("#E74C3C", alpha.f = 0.7), border = NA)
      
      # Add vertical line for snap event if it occurred
      if (length(current_data) > 1) {
        snap_gen <- current_data[[2]]$generation[1]
        abline(v = snap_gen, lty = 2, col = "purple", lwd = 2)
        text(snap_gen, max(AA_counts + Aa_counts + aa_counts) * 0.95, 
             "SNAP!", col = "purple", pos = 4, cex = 1.2)
      }
    }
    
    # Add legend
    legend("topright",
           legend = c("AA (long hair)", "Aa (long hair)", "aa (short hair)", "Bottleneck"),
           fill = c(adjustcolor("#E74C3C", alpha.f = 0.7),
                   adjustcolor("#F39C12", alpha.f = 0.7),
                   adjustcolor("#3498DB", alpha.f = 0.7),
                   NA),
           border = c(NA, NA, NA, "red"),
           lty = c(NA, NA, NA, 2),
           lwd = c(NA, NA, NA, 2),
           bg = adjustcolor("#34495E", alpha.f = 0.8),
           box.col = "white")
  })
  
  # Genotype table
  output$genotypeTable <- renderTable({
    if (is.null(population_data())) return()
    
    current_data <- population_data()
    if (phase() == "Pre-snap") {
      last_gen <- tail(current_data[[1]], 1)
    } else {
      last_gen <- tail(current_data[[2]], 1)
    }
    
    total <- last_gen$total
    if (total == 0) {
      data.frame(
        Genotype = c("AA", "Aa", "aa"),
        Phenotype = c("Long hair", "Long hair", "Short hair"),
        Count = c(0, 0, 0),
        Percentage = c("0%", "0%", "0%"),
        Description = c("Homozygous dominant", "Heterozygous", "Homozygous recessive")
      )
    } else {
      data.frame(
        Genotype = c("AA (Homozygous Dominant)", "Aa (Heterozygous)", "aa (Homozygous Recessive)"),
        Phenotype = c("Long hair", "Long hair", "Short hair"),
        Count = c(last_gen$AA, last_gen$Aa, last_gen$aa),
        Percentage = paste0(round(c(last_gen$AA/total, last_gen$Aa/total, last_gen$aa/total) * 100, 1), "%"),
        Description = c("Two dominant alleles", "One dominant, one recessive allele", "Two recessive alleles")
      )
    }
  }, bordered = TRUE, align = 'c', striped = TRUE)
}

shinyApp(ui = ui, server = server)
```

## Section Four

```{r student4}

# INSTRUCTION IDEAS

#under the left hand side of UI

#"Add population size, one or both of the initial allele frequencies, and click 'grow'! Press 'snap!' to create a bottleneck event that snaps the population in half, and click 'grow' again to watch the population increase. Press 'stop' at any point to pause the simulation. Allele proportions can be observed changing in real time during the simulation at the bottom of the graph. To reset the simulation, just enter in your population size again.


# ADD FREQUENCIES ALONG WITH CURRENT POPULATION PROPORTIONS

#below graph with current population and proportions

#each allele proportion divided by current population size to create frequencies 

```
